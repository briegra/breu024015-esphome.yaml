substitutions:
  devicename: "esp32_init"
  friendly_name: "ESP32 Init Projekt"
  mqtt_prefix: "esp32_init"
  

esphome:
  name: "${devicename}"
  friendly_name: "${friendly_name}"
  includes:
    - ap_name_mapper.h
    - loop_time_sensor.h

  on_boot:
    priority: -100  # SpÃ¤tere AusfÃ¼hrung, nachdem alles bereit ist
    then:
      - lambda: |-
          ESP_LOGE("BOOT", "ESP gestartet");
          ESP_LOGE("BOOT", "Warte auf Initialisierung: 10 Sekunden");
      - delay: 10s
      - lambda: |-
          id(restart_esp).turn_off();
          id(restart_counter)++;
          id(restart_counter_sensor).publish_state(id(restart_counter));
          id(init_done) = true;
          ESP_LOGE("BOOT", "Init abgeschlossen");

esp32:
  board: esp32dev
  framework:
    type: arduino

# Enable logging
logger:
  level: WARN
  logs:
    sensor: ERROR  
    adc: WARN      
    mqtt: WARN    
    text_sensor: WARN

ota:
  platform: esphome
  password: !secret ota_password

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

# Optional manual IP
#  manual_ip:
#    static_ip: 192.168.24.216
#    gateway: 192.168.24.1
#    subnet: 255.255.255.0      

  ap:
    ssid: "$(devicename) Fallback Hotspot"
    password: "wPsNYum3nwl9"

# Enable Home Assistant API
api:
  encryption:
    key: !secret api_key

# Enable Web server
web_server:
  port: 80

# MQTT-Basis-Konfiguration
mqtt:
  topic_prefix: "${devicename}"
  discovery: false
  broker: 192.168.24.15
  id: mqtt_client
  port: 1887
  username: !secret mqtt_user
  password: !secret mqtt_password

# SNTP
time:
  - platform: sntp
    id: system_time
    servers: time.myrbr.lcl
    timezone: Europe/Berlin
    on_time_sync:
      then:
        - logger.log: "SNTP-Zeit synchronisiert!"
        - component.update: last_boot_time_sensor  

#########################################################################################################

#############################################################
globals:
#############################################################

  # Reboot counter
  - id: restart_counter
    type: int
    restore_value: true
    initial_value: "0"

  - id: init_done
    type: bool
    restore_value: false
    initial_value: "false"


############################################################################################################################################
sensor:
############################################################################################################################################

  # WiFi SignalstÃ¤rke
  - platform: wifi_signal
    name: "WiFi-RSSI"
    update_interval: 60s
    state_topic: "${mqtt_prefix}/WiFi/RSSI"        

  # Restart Counter
  - platform: template
    name: "ESP32 Restart Counter"
    id: restart_counter_sensor
    accuracy_decimals: 0
    state_topic: "${mqtt_prefix}/ESP32/restart/counter"

  # Uptime
  - platform: uptime
    name: "Uptime"
    id: esp_uptime
    update_interval: 1000ms
    internal: true
    on_value:
      then:
        - lambda: |-
            int seconds = (int) id(esp_uptime).state;
            int days = seconds / 86400;
            seconds = seconds % 86400;
            int hours = seconds / 3600;
            seconds = seconds % 3600;
            int minutes = seconds / 60;
            seconds = seconds % 60;
            char buffer[32];
            sprintf(buffer, "%d Tage %02d:%02d:%02d", days, hours, minutes, seconds);
            id(uptime_string).publish_state(buffer);

  # ESP LOOP-Time
  - platform: custom
    lambda: |-
      auto my_sensor = new LoopTimeSensor(10000);  // âœ… Hier Update-Intervall setzen (10s)
      App.register_component(my_sensor);
      return {my_sensor};
    sensors:
      - name: "ESP32 Loop-Zeit"
        id: loop_time_sensor
        unit_of_measurement: "ms"
        accuracy_decimals: 2
        internal: true        
        on_value:
          then:
            - mqtt.publish:
                topic: ${mqtt_prefix}/ESP32/LoopTime
                payload: !lambda 'return to_string(id(loop_time_sensor).state);'



  # Interne Temperatur ESP32
  - platform: internal_temperature
    name: "ESP32 Interne Temperatur"
    filters:
      - offset: -5.0  # Korrigiert die Messung um 5 Grad nach unten
      - sliding_window_moving_average:
          window_size: 10
          send_every: 5
    update_interval: 60s
    state_topic: "${mqtt_prefix}/ESP32/IntTemperatur"



  

########################################################################################################################
text_sensor:
############################################################################################################################################

# Wifi Info
  - platform: wifi_info
    ip_address: 
      name: WiFi-IPAddress
      state_topic: "${mqtt_prefix}/WiFi/IPAddress"
      on_value:
        then:
          - lambda: 'ESP_LOGE("wifi", "IP-Adresse: %s", x.c_str());'      

    ssid:
      id: ssid
      name: WiFi-SSID
      state_topic: "${mqtt_prefix}/WiFi/SSID"

    bssid:
      id: bssid_sensor  # ID fÃ¼r die BSSID
      name: WiFi-BSSID
      state_topic: "${mqtt_prefix}/WiFi/BSSID"
      
    mac_address:
      name: WiFi-MacAddress
      state_topic: "${mqtt_prefix}/WiFi/MAC"

  - platform: custom
    lambda: |-
      auto ap_name_sensor = new APNameTemplate();
      ap_name_sensor->bssid_sensor = id(bssid_sensor);
      App.register_component(ap_name_sensor);
      return {ap_name_sensor};

    text_sensors:
      - name: "WiFi-Access Point Name"
        id: ap_name_sensor
        disabled_by_default: true     
        on_value:
          then:
            - mqtt.publish:
                topic: "${mqtt_prefix}/WiFi/AP_Name"
                payload: !lambda 'return id(ap_name_sensor).state;'      

# Last Reboot Time
  - platform: template
    name: "ESP Restart Time"
    id: last_boot_time_sensor
    icon: "mdi:clock"
    update_interval: never  # Berechnung nur bei SNTP-Sync
    state_topic: "${mqtt_prefix}/ESP32/restart/time"
    lambda: |-
      if (!id(system_time).now().is_valid()) {
        return {"Warte auf SNTP..."};
      }

      auto now = id(system_time).now();
      auto boot_timestamp = now.timestamp - (int) id(esp_uptime).state; // Uptime abziehen
      auto boot_time = esphome::ESPTime::from_epoch_local(boot_timestamp);

      char str[25];  // ðŸ”¹ Mehr Platz als nÃ¶tig, um jede Ausgabe sicher aufzunehmen
      snprintf(str, sizeof(str), "%02u.%02u.%02u %02u:%02u:%02u",
               (unsigned int) boot_time.day_of_month, 
               (unsigned int) boot_time.month, 
               (unsigned int) (boot_time.year % 100),
               (unsigned int) boot_time.hour, 
               (unsigned int) boot_time.minute, 
               (unsigned int) boot_time.second);
      return {str};

  - platform: template
    name: "ESP Uptime Formatted"
    id: uptime_string
    state_topic: "${mqtt_prefix}/ESP32/uptime"

############################################################################################################################################
output:
############################################################################################################################################

  - platform: gpio
    pin: GPIO23
    id: WiFi_led
    inverted: no

############################################################################################################################################
interval:
############################################################################################################################################

# Wifi Status
  - interval: 500ms
    then:
      if:
        condition:
          wifi.connected:
        then:
          - output.turn_on: WiFi_led
        else:
          - output.turn_on: WiFi_led
          - delay: 125ms
          - output.turn_off: WiFi_led   

############################################################################################################################################
switch:
############################################################################################################################################

# Restart ESP
  - platform: template
    name: "ESP Restart"
    id: restart_esp
    optimistic: true
    retain: true
    state_topic: "${mqtt_prefix}/ESP32/restart/state"
    command_topic: "${mqtt_prefix}/ESP32/restart/command"
    turn_on_action:
      - delay: 500ms
      - lambda: |
          ESP_LOGE("Switch", "ESP wird jetzt neugestartet...");      
          ESP.restart();          


    