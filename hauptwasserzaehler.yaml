substitutions:
  devicename: "hauptwasserzaehler"
  friendly_name: "Hauptwasserzähler"
  mqtt_prefix: "hauptwasserzaehler"
  ap_fallback: "Hauptwasserzaehler SSID"

esp32:
  board: esp32dev
  framework:
    type: arduino  

logger:
  level: DEBUG  # Gesamt-Level hochsetzen
  logs:
    sensor: WARN
    text_sensor: WARN
    wifi: WARN
    mqtt.component: WARN
    mqtt.client: WARN
    api: WARN
    web_server: WARN

esphome:
  name: "${devicename}"
  includes:
    - ap_name_mapper.h
    - loop_time_sensor.h

  on_boot:
    priority: -100
    then:
      - lambda: |-
          ESP_LOGE("BOOT", "ESP gestartet");
          ESP_LOGE("BOOT", "Warte auf Initialisierung: 10 Sekunden");
      - delay: 5s
      - lambda: |-
          id(restart_esp).turn_off();
          id(init_done) = true;
          id(restart_counter)++;
          id(restart_counter_sensor).publish_state(id(restart_counter));
          id(zaehler_total_sensor).publish_state(id(zaehler_total));
          id(verbrauch_heute_sensor).publish_state(id(verbrauch_heute));
          id(verbrauch_gestern_sensor).publish_state(id(verbrauch_gestern));
          id(verbrauch_monat_sensor).publish_state(id(verbrauch_monat));
          id(verbrauch_vormonat_sensor).publish_state(id(verbrauch_vormonat));
          id(zaehler_gestern_sensor).publish_state(id(zaehler_gestern));
          id(zaehler_vormonat_sensor).publish_state(id(zaehler_vormonat));
          id(durchfluss_sensor).publish_state(0);

          ESP_LOGE("BOOT", "Init abgeschlossen");

ota:
  password: !secret ota_password
  safe_mode: false

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "${ap_fallback}"
    password: "wPsNYum3nwl9"

#api:
#  encryption:
#    key: !secret api_key
#  reboot_timeout: 0s  # ⬅️ Deaktiviert den Auto-Reboot bei fehlender API-Verbindung    

web_server:
  port: 80

############################################################################################################################################
# time
############################################################################################################################################

time:
  - platform: sntp
    id: system_time
    servers: 
      - time.myrbr.lcl
    timezone: Europe/Berlin
    update_interval: never    
    on_time_sync:
      then:
        - logger.log: "SNTP-Zeit synchronisiert!"
#        - component.update: last_boot_time_sensor
    on_time:
      - seconds: 59
        minutes: 59
        hours: 23
        then:
          - lambda: |-
              auto now = id(system_time).now();
              if (!now.is_valid()) {
                ESP_LOGW("Ultimo", "Zeit nicht synchronisiert");
              } else {
                // Ultimo-Berechnung
                int jahr = now.year;
                int monat = now.month;
                int tag = now.day_of_month;

                struct tm ultimo_tm = { 0 };
                ultimo_tm.tm_year = jahr - 1900;
                ultimo_tm.tm_mon = monat;  // Nächster Monat
                ultimo_tm.tm_mday = 1;     // Erster Tag

                time_t ultimo_time = mktime(&ultimo_tm) - 86400; // 1 Tag abziehen
                localtime_r(&ultimo_time, &ultimo_tm);

                bool ist_ultimo = (tag == ultimo_tm.tm_mday);

                ESP_LOGI("Ultimo", "Heute ist: %04d-%02d-%02d, Berechnetes Ultimo: %04d-%02d-%02d",
                         jahr, monat, tag, ultimo_tm.tm_year + 1900, ultimo_tm.tm_mon + 1, ultimo_tm.tm_mday);

                if (ist_ultimo) {
                  id(verbrauch_vormonat) = id(verbrauch_monat);
                  id(verbrauch_vormonat_sensor).publish_state(id(verbrauch_monat));
                  id(verbrauch_monat) = 0;
                  id(zaehler_vormonat) = id(zaehler_total);
                  id(zaehler_vormonat_sensor).publish_state(id(zaehler_vormonat));
                }

                // Immer um 23:59:59, auch wenn nicht Ultimo
                id(verbrauch_gestern) = id(verbrauch_heute);
                id(verbrauch_gestern_sensor).publish_state(id(verbrauch_gestern));
                id(verbrauch_heute) = 0;
                id(zaehler_gestern) = id(zaehler_total);
                id(zaehler_gestern_sensor).publish_state(id(zaehler_gestern));
              }


############################################################################################################################################
# mqtt
############################################################################################################################################

mqtt:
  topic_prefix: "${mqtt_prefix}"
  discovery: false
  broker: mqtt.myrbr.lcl
  id: mqtt_client
  port: 1887
  username: !secret mqtt_user
  password: !secret mqtt_password

  on_disconnect:
    then:
      - lambda: |-
           id(mqtt_accept_message) = false;
           id(mqtt_connect_counter) = 0;
           ESP_LOGE("MQTT", "init_done: %d, mqtt_accept_message: %d, connect counter: %d", id(init_done), id(mqtt_accept_message), id(mqtt_connect_counter));   

  on_connect:
    then:
      - lambda: |-
           id(mqtt_connect_counter)++;
           if(id(mqtt_connect_counter) >= 1){
             id(mqtt_accept_message) = true;
           }
           ESP_LOGE("MQTT", "init_done: %d, mqtt_accept_message: %d, connect counter: %d", id(init_done), id(mqtt_accept_message), id(mqtt_connect_counter));   


  on_message:
    - topic: "${mqtt_prefix}/Zaehler/set"
      then:
        - lambda: |-
            ESP_LOGE("MQTT", "init_done: %d, mqtt_accept_message: %d, connect counter: %d", id(init_done), id(mqtt_accept_message), id(mqtt_connect_counter));   
            if(id(init_done) && id(mqtt_accept_message)){
              int new_value = atoi(x.c_str());
              id(zaehler_total) = new_value;
              if(new_value > 0){
                id(zaehler_total_sensor).publish_state(id(zaehler_total));
                ESP_LOGE("MQTT", "Zaehler wurde auf %d gesetzt", new_value);   
                global_preferences->sync();
              }
            }

############################################################################################################################################
# globals
############################################################################################################################################

globals:
  - id: init_done
    type: bool
    restore_value: false
    initial_value: "false"

  - id: restart_counter
    type: int
    restore_value: true
    initial_value: "0"

  - id: mqtt_accept_message
    type: bool
    restore_value: false
    initial_value: "false"    

  - id: mqtt_connect_counter
    type: int
    initial_value: '0'    

  - id: zaehler_total
    type: int
    restore_value: true
    initial_value: "123"

  - id: zaehler_gestern
    type: int
    restore_value: true
    initial_value: "0"

  - id: zaehler_vormonat
    type: int
    restore_value: true
    initial_value: "0"

  - id: verbrauch_heute
    type: int
    restore_value: true
    initial_value: "0"

  - id: verbrauch_monat
    type: int
    restore_value: true
    initial_value: "0"

  - id: verbrauch_vormonat
    type: int
    restore_value: true
    initial_value: "0"

  - id: verbrauch_gestern
    type: int
    restore_value: true
    initial_value: "0"

  - id: impulsdauer
    type: int
    restore_value: false
    initial_value: "0"

  - id: letzte_impulsdauer
    type: int
    restore_value: false
    initial_value: "0"

  - id: impulszaehler
    type: int
    restore_value: false
    initial_value: "-1"

  - id: flanke_impuls
    type: bool
    restore_value: false
    initial_value: "false"

  - id: flankenzaehler
    type: int
    restore_value: False
    initial_value: "0"

############################################################################################################################################
# interval
############################################################################################################################################

interval:
  - interval: 500ms
    then:
      if:
        condition:
          wifi.connected:
        then:
          - output.turn_on: WiFi_led
        else:
          - output.turn_on: WiFi_led
          - delay: 125ms
          - output.turn_off: WiFi_led

  - interval: 100ms
    then:
      - lambda: |-
          if(id(impulszaehler) >= 0){
            id(impulszaehler)++;
          }
          if (id(Liter_Impuls).state && !id(flanke_impuls)) {
            id(flanke_impuls) = true;
            id(letzte_impulsdauer) = id(impulsdauer);
            id(impulsdauer) = id(impulszaehler);
            id(flankenzaehler)++;
            if(id(flankenzaehler) > 2){
              id(impulsdauer) = id(impulszaehler);
              id(durchfluss_sensor).publish_state(3600.0/id(impulsdauer));
              ESP_LOGE("Zaehler", "Impulsdauer %d", id(impulsdauer));   
            }
            id(impulszaehler) = 0;
          }

          if(!id(Liter_Impuls).state && id(flanke_impuls)){
            id(flanke_impuls) = false;
          }

          int ueberwachungszeit = 1200;
          if(id(letzte_impulsdauer) > 0){
            ueberwachungszeit = id(letzte_impulsdauer) * 15; //Das 1,5 fache
          }

          if(id(impulszaehler) > ueberwachungszeit){
            id(impulszaehler) = -1;
            id(impulsdauer) = 0;
            id(flankenzaehler) = 0;
            id(durchfluss_sensor).publish_state(0);
          }

############################################################################################################################################
#binary_sensor:
############################################################################################################################################

binary_sensor:
  - platform: gpio
    pin:
      number: GPIO27
      mode:
        input: true
        pullup: true
    name: "Zaehler LiterImpuls"
    id: Liter_Impuls
    filters:
      - delayed_on: 1000ms
      - delayed_off: 1000ms
    state_topic: "${mqtt_prefix}/Zaehler/LiterImpuls"
    on_press:
      then:
        - delay: 1000ms  # Sicherstellen, dass der vorherige Status mindestens 1 Sekunde bestand      
        - lambda: |-

            id(zaehler_total) += 1;
            id(zaehler_total_sensor).publish_state(id(zaehler_total));

            id(verbrauch_heute) += 1;
            id(verbrauch_heute_sensor).publish_state(id(verbrauch_heute));

            id(verbrauch_monat) += 1;
            id(verbrauch_monat_sensor).publish_state(id(verbrauch_monat));

            global_preferences->sync();

############################################################################################################################################
# sensor
############################################################################################################################################

sensor:
  - platform: template
    name: "Zähler Total"
    id: zaehler_total_sensor
    accuracy_decimals: 0
    state_topic: "${mqtt_prefix}/Zaehler/total"

  - platform: template
    name: "Zähler Gestern"
    id: zaehler_gestern_sensor
    accuracy_decimals: 0
    state_topic: "${mqtt_prefix}/Zaehler/gestern"

  - platform: template
    name: "Zähler Vormonat"
    id: zaehler_vormonat_sensor
    accuracy_decimals: 0
    state_topic: "${mqtt_prefix}/Zaehler/vormonat"

  - platform: template
    name: "Verbrauch Heute"
    id: verbrauch_heute_sensor
    accuracy_decimals: 0
    state_topic: "${mqtt_prefix}/Verbrauch/heute"

  - platform: template
    name: "Verbrauch Monat"
    id: verbrauch_monat_sensor
    accuracy_decimals: 0
    state_topic: "${mqtt_prefix}/Verbrauch/monat"

  - platform: template
    name: "Verbrauch Vormonat"
    id: verbrauch_vormonat_sensor
    accuracy_decimals: 0
    state_topic: "${mqtt_prefix}/Verbrauch/vormonat"

  - platform: template
    name: "Verbrauch Durchfluss"
    id: durchfluss_sensor
    accuracy_decimals: 1
    state_topic: "${mqtt_prefix}/Verbrauch/durchfluss"

  - platform: template
    name: "Verbrauch Gestern"
    id: verbrauch_gestern_sensor
    accuracy_decimals: 0
    state_topic: "${mqtt_prefix}/Verbrauch/gestern"

  - platform: template
    name: "ESP Restart Counter"
    id: restart_counter_sensor
    accuracy_decimals: 0
    state_topic: "${mqtt_prefix}/ESP/restart/counter"

  - platform: wifi_signal
    name: "WiFi-RSSI"
    update_interval: 60s
    state_topic: "${mqtt_prefix}/WiFi/RSSI"

  - platform: uptime
    name: "Uptime"
    id: esp_uptime
    update_interval: 5000ms
    internal: true
    on_value:
      then:
        - lambda: |-
            if (id(init_done)) {
              int seconds = (int) id(esp_uptime).state;
              int days = seconds / 86400;
              seconds %= 86400;
              int hours = seconds / 3600;
              seconds %= 3600;
              int minutes = seconds / 60;
              seconds %= 60;
              char buffer[32];
              sprintf(buffer, "%d Tage %02d:%02d:%02d", days, hours, minutes, seconds);
              id(uptime_string).publish_state(buffer);
            }

  - platform: internal_temperature
    name: "ESP Interne Temperatur"
    filters:
      - offset: -5.0
      - sliding_window_moving_average:
          window_size: 10
          send_every: 5
    update_interval: 60s
    state_topic: "${mqtt_prefix}/ESP/IntTemperatur"

  - platform: custom
    lambda: |-
      auto my_sensor = new LoopTimeSensor(10000);
      App.register_component(my_sensor);
      return {my_sensor};
    sensors:
      - name: "ESP Loop-Zeit"
        id: loop_time_sensor
        unit_of_measurement: "ms"
        accuracy_decimals: 2
        internal: true
        on_value:
          then:
            - if:
                condition:
                  lambda: 'return id(init_done);'
                then:
                  - mqtt.publish:
                      topic: "${mqtt_prefix}/ESP/LoopTime"
                      payload: !lambda 'return to_string(id(loop_time_sensor).state);'

############################################################################################################################################
# output
############################################################################################################################################
output:
  - platform: gpio
    pin: GPIO2
    id: WiFi_led
    inverted: no

############################################################################################################################################
# text_sensor
############################################################################################################################################

text_sensor:
  - platform: template
    name: "ESP Restart Time"
    id: last_boot_time_sensor
    icon: "mdi:clock"
    update_interval: never
    state_topic: "${mqtt_prefix}/ESP/restart/time"
    lambda: |-
      if (!id(system_time).now().is_valid()) {
          return {"Warte auf SNTP..."};        
      }
      ESP_LOGE("BOOT", "Init abgeschlossen");
      auto now = id(system_time).now();
      auto boot_timestamp = now.timestamp - (int) id(esp_uptime).state;
      auto boot_time = esphome::ESPTime::from_epoch_local(boot_timestamp);
      char str[25];
      snprintf(str, sizeof(str), "%02u.%02u.%02u %02u:%02u:%02u",
               (unsigned int) boot_time.day_of_month,
               (unsigned int) boot_time.month,
               (unsigned int) (boot_time.year % 100),
               (unsigned int) boot_time.hour,
               (unsigned int) boot_time.minute,
               (unsigned int) boot_time.second);
      return {str};

  - platform: template
    name: "ESP Uptime Formatted"
    id: uptime_string
    state_topic: "${mqtt_prefix}/ESP/uptime"

  - platform: wifi_info
    ip_address:
      name: WiFi-IPAddress
      state_topic: "${mqtt_prefix}/WiFi/IPAddress"
    ssid:
      name: WiFi-SSID
      state_topic: "${mqtt_prefix}/WiFi/SSID"
    bssid:
      id: bssid_sensor
      name: WiFi-BSSID
      state_topic: "${mqtt_prefix}/WiFi/BSSID"
    mac_address:
      name: WiFi-MacAddress
      state_topic: "${mqtt_prefix}/WiFi/MAC"

  - platform: custom
    lambda: |-
      auto ap_name_sensor = new APNameTemplate();
      ap_name_sensor->bssid_sensor = id(bssid_sensor);
      App.register_component(ap_name_sensor);
      return {ap_name_sensor};
    text_sensors:
      - name: "WiFi-Access Point Name"
        id: ap_name_sensor
        on_value:
          then:
            - mqtt.publish:
                topic: "${devicename}/WiFi/AP_Name"
                payload: !lambda 'return id(ap_name_sensor).state;'                       

############################################################################################################################################
# switch
############################################################################################################################################

switch:
  - platform: template
    name: "ESP Restart"
    id: restart_esp
    optimistic: true
    retain: true
    state_topic: "${mqtt_prefix}/ESP/restart/state"
    command_topic: "${mqtt_prefix}/ESP/restart/command"
    turn_on_action:
      - delay: 500ms
      - lambda: |
          ESP_LOGE("Switch", "ESP wird jetzt neugestartet...");
          ESP.restart();     


