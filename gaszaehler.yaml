substitutions:
  devicename: "gaszaehler"
  friendly_name: "Gasz√§hler"

esphome:
  name: "${devicename}"
  platform: ESP8266
  board: d1_mini
  includes:
    - ap_name_mapper.h
  project:
    name: "${devicename}.version"
    version: "5.7"

  on_boot:
    priority: 600  # H√∂here Priorit√§t stellt sicher, dass dies fr√ºh passiert
    then:
      - delay: 10s
      - lambda: |-
          if (id(restart_esp)) {
            id(restart_esp).turn_off();
          }
          id(restart_counter)++;
          id(restart_counter_sensor).publish_state(id(restart_counter));
          id(verbrauch_heute_sensor).publish_state(id(verbrauch_heute));
          id(verbrauch_gestern_sensor).publish_state(id(verbrauch_Gestern));
          id(verbrauch_monat_sensor).publish_state(id(verbrauch_monat));
          id(verbrauch_vorMonat_sensor).publish_state(id(verbrauch_VorMonat));
          id(zaehler_total_sensor).publish_state(id(zaehler_total));
          id(zaehler_gestern_sensor).publish_state(id(zaehler_gestern));
          id(zaehler_vormonat_sensor).publish_state(id(zaehler_VorMonat));
          id(init_done) = true;
          ESP_LOGE("ESP", "Init durchgef√ºhrt");

# Enable persistent storage
#preferences:
#  flash_write_interval: 5min

# Enable logging
logger:
  level: WARN
  logs:
    sensor: ERROR
    adc: WARN
    mqtt: WARN
    text_sensor: WARN

ota:
  - platform: esphome
    password: "vlBpyX#7jSI5"

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "${devicename} Fallback Hotspot"
    password: "wPsNYum3nwl9"

web_server:
  port: 80

globals:
  # Konstanten
  - id: brennwert
    type: float
    restore_value: yes
    initial_value: '11.535'
  - id: zustandszahl
    type: float
    restore_value: yes
    initial_value: '0.9359'

  # Reboot Counter
  - id: restart_counter
    type: int
    restore_value: true
    initial_value: "0"

  - id: mqtt_first_message_processed
    type: bool
    restore_value: false
    initial_value: "false"

  - id: init_done
    type: bool
    restore_value: false
    initial_value: "false"

    # Volumen
  - id: Volumen
    type: int
    restore_value: true
    initial_value: "0"
  - id: verbrauch_heute
    type: int
    restore_value: true
    initial_value: "0"
  - id: volumen_dieserMonat
    type: int
    restore_value: true
    initial_value: "0"
  - id: verbrauch_Gestern
    type: int
    restore_value: true
    initial_value: "0"
  - id: verbrauch_VorMonat
    type: int
    restore_value: true
    initial_value: "0"
  - id: verbrauch_monat
    type: int
    restore_value: true
    initial_value: "0"
  - id: Volumenstand_VorMonat
    type: int
    restore_value: true
    initial_value: "0"

  # Z√§hler
  - id: zaehler_total
    type: int
    restore_value: true
    initial_value: "0"
  - id: zaehler_heute
    type: int
    restore_value: true
    initial_value: "0"
  - id: zaehler_gestern
    type: int
    restore_value: true
    initial_value: "0"
  - id: zaehler_dieserMonat
    type: int
    restore_value: true
    initial_value: "0"
  - id: zaehler_VorMonat
    type: int
    restore_value: true
    initial_value: "0"

  # Impuls spezifisch
  - id: x_was_negative
    type: bool
    restore_value: no
    initial_value: "false"
  - id: last_pulse_time
    type: float
    restore_value: yes
    initial_value: '0.0'
  - id: pulse_interval
    type: float
    restore_value: yes
    initial_value: '0.0'
  - id: negative_since
    type: float
    restore_value: no
    initial_value: '0.0'
  - id: positive_since
    type: float
    restore_value: no
    initial_value: '0.0'
  - id: ready_to_count
    type: bool
    restore_value: no
    initial_value: "false"
  - id: mag_x_counter
    type: int
    restore_value: no
    initial_value: '0'

mqtt:
  id: mqtt_client
  topic_prefix: ${devicename}
  broker: 192.168.24.15
  port: 1887
  username: !secret mqtt_user
  password: !secret mqtt_password
  discovery: false

  on_message:
    - topic: "${devicename}/Zaehler/set"
      then:
        - lambda: |-
            if(!id(init_done)){
              ESP_LOGE("MQTT", "Init war noch nicht durchgfuehrt - message wird ignoriert");
              return;
            }
            // Andernfalls wird die Nachricht verarbeitet:
            int new_value = atoi(x.c_str());
            id(zaehler_total) = new_value;
            id(zaehler_total_sensor).publish_state(id(zaehler_total));
            ESP_LOGI("MQTT", "Zaehler wurde auf %d gesetzt", new_value);

time:
  - platform: sntp
    id: system_time
    servers: time.myrbr.lcl
    timezone: Europe/Berlin
    on_time_sync:
      then:
        - logger.log: "SNTP-Zeit synchronisiert!"
        - component.update: last_boot_time_sensor
    on_time:
      - seconds: 59
        minutes: 59
        hours: 23
        then:
          - lambda: |-
              auto now = id(system_time).now();
              if (!now.is_valid()) {
                ESP_LOGW("Ultimo", "Zeit nicht synchronisiert");
              } else {
                // Ultimo-Berechnung
                int jahr = now.year;
                int monat = now.month;
                int tag = now.day_of_month;

                struct tm ultimo_tm = { 0 };
                ultimo_tm.tm_year = jahr - 1900;
                ultimo_tm.tm_mon = monat;  // N√§chster Monat
                ultimo_tm.tm_mday = 1;     // Erster Tag

                time_t ultimo_time = mktime(&ultimo_tm) - 86400; // 1 Tag abziehen
                localtime_r(&ultimo_time, &ultimo_tm);

                bool ist_ultimo = (tag == ultimo_tm.tm_mday);

                ESP_LOGI("Ultimo", "Heute ist: %04d-%02d-%02d, Berechnetes Ultimo: %04d-%02d-%02d",
                         jahr, monat, tag, ultimo_tm.tm_year + 1900, ultimo_tm.tm_mon + 1, ultimo_tm.tm_mday);

                if (ist_ultimo) {
                  ESP_LOGI("Ultimo", "Ultimo erreicht! Speichere Monatswerte...");
                  id(verbrauch_VorMonat) = id(volumen_dieserMonat);
                  id(verbrauch_vorMonat_sensor).publish_state(id(verbrauch_VorMonat));
                  id(volumen_dieserMonat) = 0;
                  id(zaehler_VorMonat) = id(zaehler_total);
                  id(zaehler_vormonat_sensor).publish_state(id(zaehler_VorMonat));
                }

                // Immer um 23:59:59, auch wenn nicht Ultimo
                ESP_LOGI("Ultimo", "T√§glicher Reset l√§uft...");
                id(verbrauch_Gestern) = id(verbrauch_heute);
                id(verbrauch_gestern_sensor).publish_state(id(verbrauch_Gestern));
                id(verbrauch_heute) = 0;
                id(zaehler_gestern) = id(zaehler_total);
                id(zaehler_gestern_sensor).publish_state(id(zaehler_gestern));
              }

i2c:
  sda: GPIO4
  scl: GPIO5
  scan: true

sensor:
  - platform: template
    name: "Restart Counter"
    id: restart_counter_sensor
    accuracy_decimals: 0
    state_topic: "${devicename}/ESP/restart/counter"
    update_interval: 1000ms

  - platform: template
    name: "Z√§hler Total"
    id: zaehler_total_sensor
    accuracy_decimals: 0
    unit_of_measurement: "L"
    state_topic: "${devicename}/Zaehler/total"
    on_value:
      then:
        - lambda: |-
            // Berechnung des Volumens in m¬≥
            float volumen_m3 = (float) id(zaehler_total_sensor).state / 100.0;

            // Energie in kWh berechnen
            float energie = volumen_m3 * id(brennwert) * id(zustandszahl);

            // Wert im "Energie Heute"-Sensor aktualisieren
            id(gesamtenergie_sensor).publish_state(energie);

  - platform: template
    name: "Energie Gesamt"
    id: gesamtenergie_sensor
    unit_of_measurement: "kWh"
    accuracy_decimals: 3
    state_topic: "${devicename}/verbrauch/energie_gesamt"

  - platform: template
    name: "Magnetfeld-X"
    id: magnetfeld_x_sensor
    state_topic: "${devicename}/brenner/magnetfeld_x"

  - platform: template
    name: "Z√§hler Vormonat"
    id: zaehler_vormonat_sensor
    accuracy_decimals: 0
    unit_of_measurement: "L"
    state_topic: "${devicename}/Zaehler/vormonat"

  - platform: template
    name: "Z√§hler Gestern"
    id: zaehler_gestern_sensor
    accuracy_decimals: 0
    unit_of_measurement: "L"
    state_topic: "${devicename}/Zaehler/gestern"

  - platform: template
    name: "Verbrauch Heute"
    id: verbrauch_heute_sensor
    accuracy_decimals: 0
    unit_of_measurement: "L"
    state_topic: "${devicename}/verbrauch/heute"
    on_value:
      then:
        - lambda: |-
            // Berechnung des Volumens in m¬≥
            float volumen_m3 = (float) id(verbrauch_heute_sensor).state / 100.0;

            // Energie in kWh berechnen
            float energie = volumen_m3 * id(brennwert) * id(zustandszahl);

            // Wert im "Energie Heute"-Sensor aktualisieren
            id(energie_heute_sensor).publish_state(energie);

  - platform: template
    name: "Energie Heute"
    id: energie_heute_sensor
    unit_of_measurement: "kWh"
    accuracy_decimals: 3
    state_topic: "${devicename}/energie/heute"

  - platform: template
    name: "Verbrauch Gestern"
    id: verbrauch_gestern_sensor
    accuracy_decimals: 0
    unit_of_measurement: "L"
    state_topic: "${devicename}/verbrauch/gestern"
    on_value:
      then:
        - lambda: |-
            // Berechnung des Volumens in m¬≥
            float volumen_m3 = (float) id(verbrauch_gestern_sensor).state / 100.0;

            // Energie in kWh berechnen
            float energie = volumen_m3 * id(brennwert) * id(zustandszahl);

            // Wert im "Energie Heute"-Sensor aktualisieren
            id(energie_gestern_sensor).publish_state(energie);

  - platform: template
    name: "Energie Gestern"
    id: energie_gestern_sensor
    unit_of_measurement: "kWh"
    accuracy_decimals: 3
    state_topic: "${devicename}/energie/gestern"

  - platform: template
    name: "Verbrauch Monat"
    id: verbrauch_monat_sensor
    accuracy_decimals: 0
    unit_of_measurement: "L"
    state_topic: "${devicename}/verbrauch/monat"
    on_value:
      then:
        - delay: 5000ms
        - lambda: |-
            // Berechnung des Volumens in m¬≥
            float volumen_m3 = (float) id(verbrauch_monat_sensor).state / 100.0;

            // Energie in kWh berechnen
            float energie = volumen_m3 * id(brennwert) * id(zustandszahl);

            // Wert im "Energie Heute"-Sensor aktualisieren
            id(energie_monat_sensor).publish_state(energie);

  - platform: template
    name: "Energie Monat"
    id: energie_monat_sensor
    unit_of_measurement: "kWh"
    accuracy_decimals: 3
    state_topic: "${devicename}/energie/monat"

  - platform: template
    name: "Verbrauch Vormonat"
    id: verbrauch_vorMonat_sensor
    accuracy_decimals: 0
    unit_of_measurement: "m¬≥"
    state_topic: "${devicename}/verbrauch/vormonat"
    on_value:
      then:
        - lambda: |-
            // Berechnung des Volumens in m¬≥
            float volumen_m3 = (float) id(verbrauch_vorMonat_sensor).state / 100.0;

            // Energie in kWh berechnen
            float energie = volumen_m3 * id(brennwert) * id(zustandszahl);

            // Wert im "Energie Heute"-Sensor aktualisieren
            id(energie_vorMonat_sensor).publish_state(energie);

  - platform: template
    name: "Energie Vormonat"
    id: energie_vorMonat_sensor
    unit_of_measurement: "kWh"
    accuracy_decimals: 3
    state_topic: "${devicename}/energie/vorMonat"

  - platform: hmc5883l
    id: mag_sensor
    address: 0x1E
    update_interval: 250ms
    field_strength_x:
      internal: true
      name: "Magnetfeld X"
      on_value:
        then:
          - lambda: |-
              float mag_x_value = x;
              float current_time = millis();

              // Z√§hlung nur bei jedem 4. Wert
              id(mag_x_counter) += 1;
              if (id(mag_x_counter) >= 4) {
                id(mag_x_counter) = 0; // Zur√ºcksetzen nach 4 Z√§hlungen
                if (id(mqtt_client) != nullptr) {
                  id(magnetfeld_x_sensor).publish_state(static_cast<float>(mag_x_value));
                }
              }

              // Negative Phase beginnt
              if (mag_x_value < -10) {
                if (!id(x_was_negative)) {
                  id(negative_since) = current_time;
                  id(x_was_negative) = true;
                }
              }

              // Positive Phase beginnt
              if (mag_x_value > 10) {
                if (id(x_was_negative) && !id(ready_to_count) && (current_time - id(negative_since) >= 2000)) {
                  id(positive_since) = current_time;
                  id(ready_to_count) = true;
                }

                // Wenn positive Phase 2000ms gedauert hat und vorher negativ war ‚Üí Z√§hler erh√∂hen
                if (id(ready_to_count) && (current_time - id(positive_since) >= 2000)) {
                  id(pulse_interval) = (current_time - id(last_pulse_time)) / 1000.0;
                  id(last_pulse_time) = current_time;

                  id(zaehler_total) += 1;
                  id(verbrauch_heute) += 1;
                  id(verbrauch_monat) += 1;

                  id(zaehler_total_sensor).publish_state(id(zaehler_total));
                  id(verbrauch_heute_sensor).publish_state(id(verbrauch_heute));
                  id(verbrauch_monat_sensor).publish_state(id(verbrauch_monat));

                  global_preferences->sync();

                  if (id(brenner_ein)) {
                    id(brenner_leistung_sensor).publish_state(0.01 * id(zustandszahl) * id(brennwert) * 3600 / ((float) id(pulse_interval)));
                  }

                  // Status zur√ºcksetzen f√ºr n√§chste Periode
                  id(x_was_negative) = false;
                  id(ready_to_count) = false;
                }
              }

  - platform: template
    name: "Brenner Leistung"
    id: brenner_leistung_sensor
    unit_of_measurement: "kW"
    accuracy_decimals: 3
    update_interval: 1000ms
    state_topic: "${devicename}/brenner/leistung"

  - platform: uptime
    name: "Uptime"
    id: esp_uptime
    update_interval: 1000ms
    internal: true
    on_value:
      then:
        - lambda: |-
            int seconds = (int) id(esp_uptime).state;
            int days = seconds / 86400;
            seconds = seconds % 86400;
            int hours = seconds / 3600;
            seconds = seconds % 3600;
            int minutes = seconds / 60;
            seconds = seconds % 60;
            char buffer[32];
            sprintf(buffer, "%d Tage %02d:%02d:%02d", days, hours, minutes, seconds);
            id(uptime_string).publish_state(buffer);

output:
  - platform: gpio
    pin: GPIO2
    id: WiFi_led
    inverted: yes

text_sensor:
  - platform: template
    name: "Restart Time"
    id: last_boot_time_sensor
    icon: "mdi:clock"
    update_interval: never  # Berechnung nur bei SNTP-Sync
    state_topic: "${devicename}/ESP/restart/time"
    lambda: |-
      if (!id(system_time).now().is_valid()) {
        return {"Warte auf SNTP..."};
      }

      auto now = id(system_time).now();
      auto boot_timestamp = now.timestamp - (int) id(esp_uptime).state; // Uptime abziehen
      auto boot_time = esphome::ESPTime::from_epoch_local(boot_timestamp);

      char str[25];  // üîπ Mehr Platz als n√∂tig, um jede Ausgabe sicher aufzunehmen
      snprintf(str, sizeof(str), "%02u.%02u.%02u %02u:%02u:%02u",
               (unsigned int) boot_time.day_of_month,
               (unsigned int) boot_time.month,
               (unsigned int) (boot_time.year % 100),
               (unsigned int) boot_time.hour,
               (unsigned int) boot_time.minute,
               (unsigned int) boot_time.second);
      return {str};

  - platform: wifi_info
    ip_address:
      name: "${devicename} IP-Adresse"
      id: wifi_ip
      on_value:
        then:
          - lambda: 'ESP_LOGE("wifi", "IP-Adresse: %s", x.c_str());'
      state_topic: "${devicename}/WiFi/IPAddress"

    ssid:
      id: ssid
      name: WiFi-SSID
      state_topic: "${devicename}/WiFi/SSID"

    bssid:
      id: bssid_sensor
      name: WiFi-BSSID
      state_topic: "${devicename}/WiFi/BSSID"

    mac_address:
      name: WiFi-MacAddress
      state_topic: "${devicename}/WiFi/MAC"

  - platform: custom
    lambda: |-
      auto ap_name_sensor = new APNameTemplate();
      ap_name_sensor->bssid_sensor = id(bssid_sensor);
      App.register_component(ap_name_sensor);
      return {ap_name_sensor};
    text_sensors:
      - name: "WiFi-Access Point Name"
        id: ap_name_sensor
        on_value:
          then:
            - mqtt.publish:
                topic: "${devicename}/WiFi/AP_Name"
                payload: !lambda 'return id(ap_name_sensor).state;'

  - platform: template
    name: "Uptime"
    id: uptime_string
    state_topic: "${devicename}/ESP/uptime"

switch:
  - platform: template
    name: "Restart ESP"
    id: restart_esp
    optimistic: true
    retain: true
    state_topic: "${devicename}/ESP/restart/state"
    command_topic: "${devicename}/ESP/restart/command"
    turn_on_action:
      - delay: 500ms
      - lambda: |
          ESP_LOGE("Switch", "ESP wird jetzt neugestartet...");
          ESP.restart();

  # Flamme ein - kommt von ioBroker
  - platform: template
    name: "Flamme ist ein"
    id: brenner_ein
    optimistic: true
    retain: true
    state_topic: "${devicename}/brenner/state"
    command_topic: "${devicename}/brenner/command"
    turn_off_action:
      - lambda: |-
          id(brenner_leistung_sensor).publish_state(0.0);

interval:
  - interval: 250ms
    then:
      if:
        condition:
          wifi.connected:
        then:
          - output.turn_on: WiFi_led
        else:
          - output.turn_on: WiFi_led
          - delay: 125ms
          - output.turn_off: WiFi_led
