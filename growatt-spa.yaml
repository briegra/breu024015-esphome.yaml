substitutions:
  devicename: "growatt-spa"
  friendly_name: "Growatt SPA"
  mqtt_prefix: "growatt-spa"
  ap_fallback: "Growatt-SPA SSID"

esp8266:
  board: esp07s

esphome:
  name: "${devicename}"
  includes:
    - ap_name_mapper.h
  libraries:
    - ArduinoJson
  on_boot:
    priority: -100
    then:
      - lambda: |-
          ESP_LOGE("BOOT", "ESP gestartet");
      - delay: 5s
      - lambda: |-
          id(restart_esp).turn_off();
          id(init_done) = true;
          id(restart_counter)++;
          id(restart_counter_sensor).publish_state(id(restart_counter));
          ESP_LOGE("BOOT", "Init abgeschlossen");

logger:
  level: WARN
  baud_rate: 0
  logs:
    sensor: ERROR
    mqtt: WARN
    text_sensor: WARN

ota:
  platform: esphome
  password: !secret ota_password_growatt

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "${ap_fallback}"
    password: "wPsNYum3nwl9"

#  manual_ip:
#    static_ip: 192.168.24.250
#    gateway: 192.168.24.1
#    subnet: 255.255.255.0
#    dns1: 192.168.24.1

web_server:
  port: 80
  local: true
  include_internal: true

time:
  - platform: sntp
    id: system_time
    servers:
      - time.myrbr.lcl
    timezone: Europe/Berlin
    on_time_sync:
      then:
        - component.update: last_boot_time_sensor

mqtt:
  topic_prefix: "${mqtt_prefix}"
  discovery: false
  broker: mqtt.myrbr.lcl
  id: mqtt_client
  port: 1887
  username: !secret mqtt_user
  password: !secret mqtt_password
  on_message:
    - topic: growatt-spa/command/json_config
      then:
        - lambda: |-
            id(mqtt_json_receiver).publish_state(x);

globals:
  - id: init_done
    type: bool
    restore_value: false
    initial_value: "false"

  - id: restart_counter
    type: int
    restore_value: true
    initial_value: "0"

  - id: zaehler_total
    type: int
    restore_value: true
    initial_value: "0"

uart:
  id: mod_bus
  tx_pin: 1
  rx_pin: 3
  baud_rate: 115200

modbus:
  id: modbus1
  uart_id: mod_bus

modbus_controller:
  - id: growatt
    address: 0x01
    modbus_id: modbus1
    setup_priority: -10
    update_interval: 5s

############################################################################################################################################
# LED (3 LEDs übernommen)
############################################################################################################################################

output:
  - id: light_bl
    platform: gpio
    pin: 16
  - id: light_gr
    platform: gpio
    pin: 0
  - id: light_rd
    platform: gpio
    pin: 2

interval:
  - interval: 500ms
    then:
      if:
        condition:
          wifi.connected:
        then:
          - output.turn_on: light_gr
          - output.turn_off: light_rd
        else:
          - output.turn_off: light_gr
          - output.turn_on: light_rd
          - delay: 125ms
          - output.turn_off: light_rd

############################################################################################################################################
# SENSOR
############################################################################################################################################

sensor:
  - platform: template
    name: "ESP Restart Counter"
    id: restart_counter_sensor
    accuracy_decimals: 0
    state_topic: "${mqtt_prefix}/ESP/restart/counter"

  - platform: wifi_signal
    name: "WiFi-RSSI"
    update_interval: 60s
    state_topic: "${mqtt_prefix}/WiFi/RSSI"

  - platform: uptime
    name: "Uptime"
    id: esp_uptime
    update_interval: 5000ms
    internal: true
    on_value:
      then:
        - lambda: |-
            if (id(init_done)) {
              int seconds = (int) id(esp_uptime).state;
              int days = seconds / 86400;
              seconds %= 86400;
              int hours = seconds / 3600;
              seconds %= 3600;
              int minutes = seconds / 60;
              seconds %= 60;
              char buffer[32];
              sprintf(buffer, "%d Tage %02d:%02d:%02d", days, hours, minutes, seconds);
              id(uptime_string).publish_state(buffer);
            }

  ###########################################################################
  # Holding-Register (nur Web-UI, NICHT MQTT)
  ###########################################################################

  - platform: modbus_controller
    modbus_controller_id: growatt
    name: "Reg 1092 - AC Charge Switch"
    address: 1092
    register_type: holding
    value_type: U_WORD
    internal: true

  - platform: modbus_controller
    modbus_controller_id: growatt
    name: "Reg 1090 - Charge Power Rate"
    address: 1090
    register_type: holding
    value_type: U_WORD
    internal: true

  # Offset-Test (nur Sichtbarkeit/Debug in Web-UI)
  - platform: modbus_controller
    modbus_controller_id: growatt
    name: "Reg 1089 - Charge Power Rate (Offset Test)"
    address: 1089
    register_type: holding
    value_type: U_WORD
    internal: true

  - platform: modbus_controller
    modbus_controller_id: growatt
    name: "Reg 1100 - BatFirst Start 1"
    address: 1100
    register_type: holding
    value_type: U_WORD
    internal: true

  - platform: modbus_controller
    modbus_controller_id: growatt
    name: "Reg 1101 - BatFirst Stop 1"
    address: 1101
    register_type: holding
    value_type: U_WORD
    internal: true

  - platform: modbus_controller
    modbus_controller_id: growatt
    name: "Reg 1102 - BatFirst Enable 1"
    address: 1102
    register_type: holding
    value_type: U_WORD
    internal: true

  # GridFirst (nur Serie 1) - Debug / Web-UI
  - platform: modbus_controller
    modbus_controller_id: growatt
    name: "Reg 1070 - GridFirst Discharge Power Rate"
    address: 1070
    register_type: holding
    value_type: U_WORD
    internal: true

  - platform: modbus_controller
    modbus_controller_id: growatt
    name: "Reg 1071 - GridFirst Stop SOC"
    address: 1071
    register_type: holding
    value_type: U_WORD
    internal: true

  - platform: modbus_controller
    modbus_controller_id: growatt
    name: "Reg 1080 - GridFirst Start 1"
    address: 1080
    register_type: holding
    value_type: U_WORD
    internal: true

  - platform: modbus_controller
    modbus_controller_id: growatt
    name: "Reg 1081 - GridFirst Stop 1"
    address: 1081
    register_type: holding
    value_type: U_WORD
    internal: true

  - platform: modbus_controller
    modbus_controller_id: growatt
    name: "Reg 1082 - GridFirst Enable 1"
    address: 1082
    register_type: holding
    value_type: U_WORD
    internal: true

  ###########################################################################
  # Messwerte (MQTT + Web-UI)
  ###########################################################################

  - platform: modbus_controller
    modbus_controller_id: growatt
    name: "Battery charge status"
    address: 1014
    register_type: "read"
    value_type: U_WORD
    unit_of_measurement: "%"

  - platform: modbus_controller
    modbus_controller_id: growatt
    name: "Discharge power - current"
    address: 1009
    register_type: "read"
    value_type: U_DWORD
    unit_of_measurement: "W"
    accuracy_decimals: 1
    filters:
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: growatt
    name: "Charge power - current"
    address: 1011
    register_type: "read"
    value_type: U_DWORD
    unit_of_measurement: "W"
    accuracy_decimals: 1
    filters:
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: growatt
    name: "Battery Temperature"
    address: 1040
    register_type: "read"
    value_type: U_WORD
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    filters:
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: growatt
    name: "SP DSP Status Charge/Discharge"
    address: 1041
    register_type: "read"
    value_type: U_WORD

  - platform: modbus_controller
    modbus_controller_id: growatt
    name: "Energy to grid - today"
    address: 1048
    register_type: "read"
    value_type: U_DWORD
    unit_of_measurement: "kWh"
    accuracy_decimals: 1
    filters:
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: growatt
    name: "Energy to grid - total"
    address: 1050
    register_type: "read"
    value_type: U_DWORD
    unit_of_measurement: "kWh"
    accuracy_decimals: 1
    filters:
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: growatt
    name: "Discharge energy1 - today"
    address: 1052
    register_type: "read"
    value_type: U_DWORD
    unit_of_measurement: "kWh"
    accuracy_decimals: 1
    filters:
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: growatt
    name: "Discharge energy1 - total"
    address: 1054
    register_type: "read"
    value_type: U_DWORD
    unit_of_measurement: "kWh"
    accuracy_decimals: 1
    filters:
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: growatt
    name: "Charge energy1 - today"
    address: 1056
    register_type: "read"
    value_type: U_DWORD
    unit_of_measurement: "kWh"
    accuracy_decimals: 1
    filters:
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: growatt
    name: "Charge energy1 - total"
    address: 1058
    register_type: "read"
    value_type: U_DWORD
    unit_of_measurement: "kWh"
    accuracy_decimals: 1
    filters:
      - multiply: 0.1

############################################################################################################################################
# TEXT SENSOR
############################################################################################################################################

text_sensor:
  - platform: template
    name: "Letzter MQTT JSON Befehl"
    id: mqtt_json_receiver
    icon: "mdi:code-json"
    on_value:
      then:
        - lambda: |-
            StaticJsonDocument<256> doc;
            DeserializationError error = deserializeJson(doc, x);
            if (error) {
              ESP_LOGW("MODBUS", "JSON Parse Error");
              return;
            }

            using namespace esphome::modbus_controller;

            // ----------------------------------------------------------------
            // BatteryFirst (Legacy Keys)
            // ----------------------------------------------------------------

            // 1090 - Charge Power Rate
            if (doc.containsKey("power_rate")) {
              int v = doc["power_rate"];
              id(growatt).queue_command(
                ModbusCommandItem::create_write_single_command(id(growatt), 1090, (uint16_t)v)
              );
              ESP_LOGW("MODBUS", "WRITE 1090 = %d", v);
            }

            // 1091 - Charge Stopped SOC
            if (doc.containsKey("stop_soc")) {
              int v = doc["stop_soc"];
              id(growatt).queue_command(
                ModbusCommandItem::create_write_single_command(id(growatt), 1091, (uint16_t)v)
              );
              ESP_LOGW("MODBUS", "WRITE 1091 = %d", v);
            }

            // 1092 - AC Charge
            if (doc.containsKey("ac")) {
              int v = doc["ac"];
              id(growatt).queue_command(
                ModbusCommandItem::create_write_single_command(id(growatt), 1092, (uint16_t)v)
              );
              ESP_LOGW("MODBUS", "WRITE 1092 = %d", v);
            }

            // 1100 - Start Time
            if (doc.containsKey("start")) {
              int v = doc["start"];
              id(growatt).queue_command(
                ModbusCommandItem::create_write_single_command(id(growatt), 1100, (uint16_t)v)
              );
              ESP_LOGW("MODBUS", "WRITE 1100 = %d", v);
            }

            // 1101 - Stop Time
            if (doc.containsKey("stop")) {
              int v = doc["stop"];
              id(growatt).queue_command(
                ModbusCommandItem::create_write_single_command(id(growatt), 1101, (uint16_t)v)
              );
              ESP_LOGW("MODBUS", "WRITE 1101 = %d", v);
            }

            // 1102 - Bat First Enable (Legacy)
            if (doc.containsKey("bat_first")) {
              int v = doc["bat_first"];
              id(growatt).queue_command(
                ModbusCommandItem::create_write_single_command(id(growatt), 1102, (uint16_t)v)
              );
              ESP_LOGW("MODBUS", "WRITE 1102 = %d", v);
            }

            // ----------------------------------------------------------------
            // BatteryFirst (New Keys: bf_* ; Serie 1)
            // ----------------------------------------------------------------

            // 1090
            if (doc.containsKey("bf_power_rate")) {
              int v = doc["bf_power_rate"];
              id(growatt).queue_command(
                ModbusCommandItem::create_write_single_command(id(growatt), 1090, (uint16_t)v)
              );
              ESP_LOGW("MODBUS", "WRITE 1090 = %d", v);
            }

            // 1091
            if (doc.containsKey("bf_stop_soc")) {
              int v = doc["bf_stop_soc"];
              id(growatt).queue_command(
                ModbusCommandItem::create_write_single_command(id(growatt), 1091, (uint16_t)v)
              );
              ESP_LOGW("MODBUS", "WRITE 1091 = %d", v);
            }

            // 1092
            if (doc.containsKey("bf_ac")) {
              int v = doc["bf_ac"];
              id(growatt).queue_command(
                ModbusCommandItem::create_write_single_command(id(growatt), 1092, (uint16_t)v)
              );
              ESP_LOGW("MODBUS", "WRITE 1092 = %d", v);
            }

            // 1100
            if (doc.containsKey("bf_start1")) {
              int v = doc["bf_start1"];
              id(growatt).queue_command(
                ModbusCommandItem::create_write_single_command(id(growatt), 1100, (uint16_t)v)
              );
              ESP_LOGW("MODBUS", "WRITE 1100 = %d", v);
            }

            // 1101
            if (doc.containsKey("bf_stop1")) {
              int v = doc["bf_stop1"];
              id(growatt).queue_command(
                ModbusCommandItem::create_write_single_command(id(growatt), 1101, (uint16_t)v)
              );
              ESP_LOGW("MODBUS", "WRITE 1101 = %d", v);
            }

            // 1102
            if (doc.containsKey("bf_en1")) {
              int v = doc["bf_en1"];
              id(growatt).queue_command(
                ModbusCommandItem::create_write_single_command(id(growatt), 1102, (uint16_t)v)
              );
              ESP_LOGW("MODBUS", "WRITE 1102 = %d", v);
            }

            // ----------------------------------------------------------------
            // GridFirst (New Keys: gf_* ; Serie 1)
            // GridFirst Writes: Function Code 0x10 (Write Multiple) mit Count=1,
            // weil der Slave FC06 (0x06) hier mit Exception 1 abgelehnt hat.
            // ----------------------------------------------------------------

            // 1070 - Discharge Power Rate
            if (doc.containsKey("gf_power_rate")) {
              uint16_t v = (uint16_t) (int) doc["gf_power_rate"];
              std::vector<uint16_t> values{v};
              id(growatt).queue_command(
                ModbusCommandItem::create_write_multiple_command(id(growatt), 1070, (uint16_t)values.size(), values)
              );
              ESP_LOGW("MODBUS", "WRITE(0x10) 1070 = %u", v);
            }

            // 1071 - Stop SOC
            if (doc.containsKey("gf_stop_soc")) {
              uint16_t v = (uint16_t) (int) doc["gf_stop_soc"];
              std::vector<uint16_t> values{v};
              id(growatt).queue_command(
                ModbusCommandItem::create_write_multiple_command(id(growatt), 1071, (uint16_t)values.size(), values)
              );
              ESP_LOGW("MODBUS", "WRITE(0x10) 1071 = %u", v);
            }

            // gf_ac ist nur Platzhalter fürs symmetrische JSON-Layout -> absichtlich ignoriert

            // 1080 - Start 1
            if (doc.containsKey("gf_start1")) {
              uint16_t v = (uint16_t) (int) doc["gf_start1"];
              std::vector<uint16_t> values{v};
              id(growatt).queue_command(
                ModbusCommandItem::create_write_multiple_command(id(growatt), 1080, (uint16_t)values.size(), values)
              );
              ESP_LOGW("MODBUS", "WRITE(0x10) 1080 = %u", v);
            }

            // 1081 - Stop 1
            if (doc.containsKey("gf_stop1")) {
              uint16_t v = (uint16_t) (int) doc["gf_stop1"];
              std::vector<uint16_t> values{v};
              id(growatt).queue_command(
                ModbusCommandItem::create_write_multiple_command(id(growatt), 1081, (uint16_t)values.size(), values)
              );
              ESP_LOGW("MODBUS", "WRITE(0x10) 1081 = %u", v);
            }

            // 1082 - Enable 1
            if (doc.containsKey("gf_en1")) {
              uint16_t v = (uint16_t) (int) doc["gf_en1"];
              std::vector<uint16_t> values{v};
              id(growatt).queue_command(
                ModbusCommandItem::create_write_multiple_command(id(growatt), 1082, (uint16_t)values.size(), values)
              );
              ESP_LOGW("MODBUS", "WRITE(0x10) 1082 = %u", v);
            }

  - platform: template
    name: "ESP Restart Time"
    id: last_boot_time_sensor
    icon: "mdi:clock"
    update_interval: never
    state_topic: "${mqtt_prefix}/ESP/restart/time"
    lambda: |-
      if (!id(system_time).now().is_valid()) {
          return {"Warte auf SNTP..."};
      }
      auto now = id(system_time).now();
      auto boot_timestamp = now.timestamp - (int) id(esp_uptime).state;
      auto boot_time = esphome::ESPTime::from_epoch_local(boot_timestamp);
      char str[25];
      snprintf(str, sizeof(str), "%02u.%02u.%02u %02u:%02u:%02u",
               (unsigned int) boot_time.day_of_month,
               (unsigned int) boot_time.month,
               (unsigned int) (boot_time.year % 100),
               (unsigned int) boot_time.hour,
               (unsigned int) boot_time.minute,
               (unsigned int) boot_time.second);
      return {str};

  - platform: template
    name: "ESP Uptime Formatted"
    id: uptime_string
    state_topic: "${mqtt_prefix}/ESP/uptime"

  - platform: wifi_info
    ip_address:
      name: WiFi-IPAddress
      state_topic: "${mqtt_prefix}/WiFi/IPAddress"
    ssid:
      name: WiFi-SSID
      state_topic: "${mqtt_prefix}/WiFi/SSID"
    bssid:
      id: bssid_sensor
      name: WiFi-BSSID
      state_topic: "${mqtt_prefix}/WiFi/BSSID"
    mac_address:
      name: WiFi-MacAddress
      state_topic: "${mqtt_prefix}/WiFi/MAC"

  - platform: custom
    lambda: |-
      auto ap_name_sensor = new APNameTemplate();
      ap_name_sensor->bssid_sensor = id(bssid_sensor);
      App.register_component(ap_name_sensor);
      return {ap_name_sensor};
    text_sensors:
      - name: "WiFi-Access Point Name"
        id: ap_name_sensor
        disabled_by_default: true
        on_value:
          then:
            - if:
                condition:
                  lambda: 'return id(init_done);'
                then:
                  - mqtt.publish:
                      topic: "${mqtt_prefix}/WiFi/AP_Name"
                      payload: !lambda 'return id(ap_name_sensor).state;'

switch:
  - platform: template
    name: "ESP Restart"
    id: restart_esp
    optimistic: true
    retain: true
    state_topic: "${mqtt_prefix}/ESP/restart/state"
    command_topic: "${mqtt_prefix}/ESP/restart/command"
    turn_on_action:
      - delay: 500ms
      - lambda: ESP.restart();
